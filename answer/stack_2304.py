# Q.
# N 개의 막대 기둥이 일렬로 세워져 있다. 기둥들의 폭은 모두 1 m이며 높이는 다를 수 있다.
# 이 기둥들을 이용하여 양철로 된 창고를 제작하려고 한다. 창고에는 모든 기둥이 들어간다.
# 이 창고의 지붕을 다음과 같이 만든다.
#
# 지붕은 수평 부분과 수직 부분으로 구성되며, 모두 연결되어야 한다.
# 지붕의 수평 부분은 반드시 어떤 기둥의 윗면과 닿아야 한다.
# 지붕의 수직 부분은 반드시 어떤 기둥의 옆면과 닿아야 한다.
# 지붕의 가장자리는 땅에 닿아야 한다.
# 비가 올 때 물이 고이지 않도록 지붕의 어떤 부분도 오목하게 들어간 부분이 없어야 한다.
# 그림 1은 창고를 옆에서 본 모습을 그린 것이다.
# 이 그림에서 굵은 선으로 표시된 부분이 지붕에 해당되고,
# 지붕과 땅으로 둘러싸인 다각형이 창고를 옆에서 본 모습이다.
# 이 다각형을 창고 다각형이라고 하자.
#
# 창고 주인은 창고 다각형의 면적이 가장 작은 창고를 만들기를 원한다.
# 그림 1에서 창고 다각형의 면적은 98 ㎡이고, 이 경우가 가장 작은 창고 다각형이다.
#
# 기둥들의 위치와 높이가 주어질 때, 가장 작은 창고 다각형의 면적을 구하는 프로그램을 작성하시오.
#
# Input.
# 첫 줄에는 기둥의 개수를 나타내는 정수 N이 주어진다. N은 1 이상 1,000 이하이다.
# 그 다음 N 개의 줄에는 각 줄에 각 기둥의 왼쪽 면의 위치를 나타내는 정수 L과
# 높이를 나타내는 정수 H가 한 개의 빈 칸을 사이에 두고 주어진다.
# L과 H는 둘 다 1 이상 1,000 이하이다.
#
# Output.
# 첫 줄에 창고 다각형의 면적을 나타내는 정수를 출력한다.

# 1. 처음에 스택에 넣고 바닥 카운트 +1
# 2. 그 다음 값이 이전값보다 작으면 넣지않고 바닥 카운트 +1
# 3. 그 다음 값이 이전값보다 큰 경우 pop으로 이전꺼 꺼내고 바닥 카운트랑 곱하기 한 후
# 4. 바닥 카운트 리셋하고, 그 다음 값을 스택에 넣음
# 5. 마지막 값보다 높이가 작은 경우는 바닥만 카운트 함
#
# N = int(input())
# result = 0
# pillar = []
# for _ in range(N) :
#     x, y = map(int,input().split())
#     pillar.append([x,y])
# pillar.sort()
#
# max = 0
# for i in range(N) :
#     while pillar[i][1] >= pillar[i+1][1]  :
#             floor += pillar[i+1]-pillar[i]

N = int(input())
pillar = []
result = 0

for _ in range(N) :
    x, y = map(int,input().split())
    pillar.append([x,y]) # 튜플 형태로
pillar.sort()


# 제일 높은 기둥을 기준으로 좌 우를 다르게 계산한다
i = 0
for p in pillar :
    if p[1] > result :
        result = p[1]
        max = i
    i += 1


# 높은 기둥을 기준으로 왼쪽인 경우, 자신보다 높은 기둥이 나오기 전까지는 영역을 자기 높이에 곱해서 더해줌
# 자신(i)보다 높은 기둥(i+1)이 나오면, 자신(i)까지만 결과에 더해주고 높이값을 높은 기둥(i+1) 값으로 바꿔줌
height = pillar[0][1]
for i in range(max) :
    if height < pillar[i+1][1] :
        result += height * (pillar[i+1][0] - pillar[i][0])
        height = pillar[i+1][1]
    else :
        result += height * (pillar[i+1][0] - pillar[i][0])


# 높은 기둥을 기준으로 오른쪽인 경우, 자신보다 높은 기둥이 나오기 전까지는 영역을 자기 높이에 곱해서 더해줌
# 자신(i)보다 높은 기둥(i-1)이 나오면, 자신(i)까지만 결과에 더해주고 높이값을 높은 기둥(i-1) 값으로 바꿔줌
# max 기둥이 나오기 직전까지만 계산함 (위에서 max 기둥까지의 영역을 계산했기 떄문에)
height = pillar[-1][1]
for i in range(N-1, max, -1) :
    if height < pillar[i-1][1] :
        result += height * (pillar[i][0] - pillar[i-1][0])
        height = pillar[i-1][1]
    else :
        result += height * (pillar[i][0] - pillar[i-1][0])

print(result)



